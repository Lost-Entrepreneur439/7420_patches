From f99a90787e008b8f3548a4e085806d757b1669d4 Mon Sep 17 00:00:00 2001
From: Dominggoes Isakh <drjisakh@gmail.com>
Date: Thu, 25 Nov 2021 21:28:54 +0100
Subject: [PATCH 1/9] Revert "eliminate TrafficController's mBpfEnabled &
 friends"

This reverts commit ec36c89c5e6cc6beb7b8ca65e23c824e04a85cdc.

Change-Id: I4d4306f4fb91d1214b33607f07922b57a6ae1555
---
 server/FirewallController.cpp | 33 ++++++++-------
 server/TrafficController.cpp  | 77 ++++++++++++++++++++++++++++++-----
 server/TrafficController.h    |  8 ++++
 3 files changed, 91 insertions(+), 27 deletions(-)

diff --git a/server/FirewallController.cpp b/server/FirewallController.cpp
index 35fd1e20..28be9a06 100644
--- a/server/FirewallController.cpp
+++ b/server/FirewallController.cpp
@@ -53,6 +53,10 @@ constexpr const uid_t kDefaultMaximumUid = UID_MAX - 1;  // UID_MAX defined as U
 // Proc file containing the uid mapping for the user namespace of the current process.
 const char kUidMapProcFile[] = "/proc/self/uid_map";
 
+bool getBpfOwnerStatus() {
+    return gCtls->trafficCtrl.getBpfEnabled();
+}
+
 }  // namespace
 
 namespace android {
@@ -90,10 +94,8 @@ FirewallController::FirewallController(void) : mMaxUid(discoverMaximumValidUid(k
 }
 
 int FirewallController::setupIptablesHooks(void) {
-    int res = flushRules();
-
-    // mUseBpfOwnerMatch should be removed, but it is still depended upon by test code.
-    mUseBpfOwnerMatch = true;
+    int res = 0;
+    mUseBpfOwnerMatch = getBpfOwnerStatus();
     if (mUseBpfOwnerMatch) {
         return res;
     }
@@ -127,22 +129,19 @@ int FirewallController::setFirewallType(FirewallType ftype) {
     return res ? -EREMOTEIO : 0;
 }
 
-int FirewallController::flushRules() {
-    std::string command =
-            "*filter\n"
-            ":fw_INPUT -\n"
-            ":fw_OUTPUT -\n"
-            ":fw_FORWARD -\n"
-            "-6 -A fw_OUTPUT ! -o lo -s ::1 -j DROP\n"
-            "COMMIT\n";
-
-    return (execIptablesRestore(V4V6, command.c_str()) == 0) ? 0 : -EREMOTEIO;
-}
-
 int FirewallController::resetFirewall(void) {
     mFirewallType = ALLOWLIST;
     mIfaceRules.clear();
-    return flushRules();
+
+    // flush any existing rules
+    std::string command =
+        "*filter\n"
+        ":fw_INPUT -\n"
+        ":fw_OUTPUT -\n"
+        ":fw_FORWARD -\n"
+        "COMMIT\n";
+
+    return (execIptablesRestore(V4V6, command.c_str()) == 0) ? 0 : -EREMOTEIO;
 }
 
 int FirewallController::enableChildChains(ChildChain chain, bool enable) {
diff --git a/server/TrafficController.cpp b/server/TrafficController.cpp
index 1f678cbf..29d04a39 100644
--- a/server/TrafficController.cpp
+++ b/server/TrafficController.cpp
@@ -52,16 +52,13 @@
 #include "netdutils/DumpWriter.h"
 #include "qtaguid/qtaguid.h"
 
+using namespace android::bpf;  // NOLINT(google-build-using-namespace): grandfathered
+
 namespace android {
 namespace net {
 
 using base::StringPrintf;
 using base::unique_fd;
-using bpf::getSocketCookie;
-using bpf::NONEXISTENT_COOKIE;
-using bpf::OVERFLOW_COUNTERSET;
-using bpf::retrieveProgram;
-using bpf::synchronizeKernelRCU;
 using netdutils::DumpWriter;
 using netdutils::extract;
 using netdutils::ScopedIndent;
@@ -171,11 +168,14 @@ StatusOr<std::unique_ptr<NetlinkListenerInterface>> TrafficController::makeSkDes
 }
 
 TrafficController::TrafficController()
-    : mPerUidStatsEntriesLimit(PER_UID_STATS_ENTRIES_LIMIT),
+    : mBpfEnabled(isBpfSupported()),
+      mPerUidStatsEntriesLimit(PER_UID_STATS_ENTRIES_LIMIT),
       mTotalUidStatsEntriesLimit(TOTAL_UID_STATS_ENTRIES_LIMIT) {}
 
 TrafficController::TrafficController(uint32_t perUidLimit, uint32_t totalLimit)
-    : mPerUidStatsEntriesLimit(perUidLimit), mTotalUidStatsEntriesLimit(totalLimit) {}
+    : mBpfEnabled(isBpfSupported()),
+      mPerUidStatsEntriesLimit(perUidLimit),
+      mTotalUidStatsEntriesLimit(totalLimit) {}
 
 Status TrafficController::initMaps() {
     std::lock_guard guard(mMutex);
@@ -248,6 +248,10 @@ static Status initPrograms() {
 }
 
 Status TrafficController::start() {
+    if (!mBpfEnabled) {
+        return netdutils::status::ok;
+    }
+
     /* When netd restarts from a crash without total system reboot, the program
      * is still attached to the cgroup, detach it so the program can be freed
      * and we can load and attach new program into the target cgroup.
@@ -311,6 +315,11 @@ int TrafficController::tagSocket(int sockFd, uint32_t tag, uid_t uid, uid_t call
         return -EPERM;
     }
 
+    if (!mBpfEnabled) {
+        if (legacy_tagSocket(sockFd, tag, uid)) return -errno;
+        return 0;
+    }
+
     uint64_t sock_cookie = getSocketCookie(sockFd);
     if (sock_cookie == NONEXISTENT_COOKIE) return -errno;
     UidTagValue newKey = {.uid = (uint32_t)uid, .tag = tag};
@@ -374,6 +383,10 @@ int TrafficController::tagSocket(int sockFd, uint32_t tag, uid_t uid, uid_t call
 
 int TrafficController::untagSocket(int sockFd) {
     std::lock_guard guard(mMutex);
+    if (!mBpfEnabled) {
+        if (legacy_untagSocket(sockFd)) return -errno;
+        return 0;
+    }
     uint64_t sock_cookie = getSocketCookie(sockFd);
 
     if (sock_cookie == NONEXISTENT_COOKIE) return -errno;
@@ -391,6 +404,11 @@ int TrafficController::setCounterSet(int counterSetNum, uid_t uid, uid_t calling
     std::lock_guard guard(mMutex);
     if (!hasUpdateDeviceStatsPermission(callingUid)) return -EPERM;
 
+    if (!mBpfEnabled) {
+        if (legacy_setCounterSet(counterSetNum, uid)) return -errno;
+        return 0;
+    }
+
     // The default counter set for all uid is 0, so deleting the current counterset for that uid
     // will automatically set it to 0.
     if (counterSetNum == 0) {
@@ -419,6 +437,11 @@ int TrafficController::deleteTagData(uint32_t tag, uid_t uid, uid_t callingUid)
     std::lock_guard guard(mMutex);
     if (!hasUpdateDeviceStatsPermission(callingUid)) return -EPERM;
 
+    if (!mBpfEnabled) {
+        if (legacy_deleteTagData(tag, uid)) return -errno;
+        return 0;
+    }
+
     // First we go through the cookieTagMap to delete the target uid tag combination. Or delete all
     // the tags related to the uid if the tag is 0.
     const auto deleteMatchedCookieEntries = [uid, tag](const uint64_t& key,
@@ -479,6 +502,8 @@ int TrafficController::deleteTagData(uint32_t tag, uid_t uid, uid_t callingUid)
 }
 
 int TrafficController::addInterface(const char* name, uint32_t ifaceIndex) {
+    if (!mBpfEnabled) return 0;
+
     IfaceValue iface;
     if (ifaceIndex == 0) {
         ALOGE("Unknown interface %s(%d)", name, ifaceIndex);
@@ -569,6 +594,10 @@ Status TrafficController::updateUidOwnerMap(const std::vector<uint32_t>& appUids
 
 int TrafficController::changeUidOwnerRule(ChildChain chain, uid_t uid, FirewallRule rule,
                                           FirewallType type) {
+    if (!mBpfEnabled) {
+        ALOGE("bpf is not set up, should use iptables rule");
+        return -ENOSYS;
+    }
     Status res;
     switch (chain) {
         case DOZABLE:
@@ -621,6 +650,10 @@ Status TrafficController::replaceRulesInMap(const UidOwnerMatchType match,
 
 Status TrafficController::addUidInterfaceRules(const int iif,
                                                const std::vector<int32_t>& uidsToAdd) {
+    if (!mBpfEnabled) {
+        ALOGW("UID ingress interface filtering not possible without BPF owner match");
+        return statusFromErrno(EOPNOTSUPP, "eBPF not supported");
+    }
     if (!iif) {
         return statusFromErrno(EINVAL, "Interface rule must specify interface");
     }
@@ -636,6 +669,10 @@ Status TrafficController::addUidInterfaceRules(const int iif,
 }
 
 Status TrafficController::removeUidInterfaceRules(const std::vector<int32_t>& uidsToDelete) {
+    if (!mBpfEnabled) {
+        ALOGW("UID ingress interface filtering not possible without BPF owner match");
+        return statusFromErrno(EOPNOTSUPP, "eBPF not supported");
+    }
     std::lock_guard guard(mMutex);
 
     for (auto uid : uidsToDelete) {
@@ -708,9 +745,17 @@ int TrafficController::toggleUidOwnerMap(ChildChain chain, bool enable) {
     return -res.code();
 }
 
+bool TrafficController::getBpfEnabled() {
+    return mBpfEnabled;
+}
+
 Status TrafficController::swapActiveStatsMap() {
     std::lock_guard guard(mMutex);
 
+    if (!mBpfEnabled) {
+        return statusFromErrno(EOPNOTSUPP, "This device doesn't have eBPF support");
+    }
+
     uint32_t key = CURRENT_STATS_MAP_CONFIGURATION_KEY;
     auto oldConfiguration = mConfigurationMap.readValue(key);
     if (!oldConfiguration.ok()) {
@@ -753,9 +798,12 @@ void TrafficController::setPermissionForUids(int permission, const std::vector<u
             // Clean up all permission information for the related uid if all the
             // packages related to it are uninstalled.
             mPrivilegedUser.erase(uid);
-            Status ret = mUidPermissionMap.deleteValue(uid);
-            if (!isOk(ret) && ret.code() != ENOENT) {
-                ALOGE("Failed to clean up the permission for %u: %s", uid, strerror(ret.code()));
+            if (mBpfEnabled) {
+                Status ret = mUidPermissionMap.deleteValue(uid);
+                if (!isOk(ret) && ret.code() != ENOENT) {
+                    ALOGE("Failed to clean up the permission for %u: %s", uid,
+                          strerror(ret.code()));
+                }
             }
         }
         return;
@@ -770,6 +818,10 @@ void TrafficController::setPermissionForUids(int permission, const std::vector<u
             mPrivilegedUser.erase(uid);
         }
 
+        // Skip the bpf map operation if not supported.
+        if (!mBpfEnabled) {
+            continue;
+        }
         // The map stores all the permissions that the UID has, except if the only permission
         // the UID has is the INTERNET permission, then the UID should not appear in the map.
         if (permission != INetd::PERMISSION_INTERNET) {
@@ -825,6 +877,11 @@ void TrafficController::dump(DumpWriter& dw, bool verbose) {
     dw.println("TrafficController");
 
     ScopedIndent indentPreBpfModule(dw);
+    dw.println("BPF module status: %s", mBpfEnabled ? "enabled" : "disabled");
+
+    if (!mBpfEnabled) {
+        return;
+    }
 
     dw.blankline();
     dw.println("mCookieTagMap status: %s",
diff --git a/server/TrafficController.h b/server/TrafficController.h
index 2e799598..deda05c3 100644
--- a/server/TrafficController.h
+++ b/server/TrafficController.h
@@ -77,6 +77,12 @@ class TrafficController {
      */
     int deleteTagData(uint32_t tag, uid_t uid, uid_t callingUid) EXCLUDES(mMutex);
 
+    /*
+     * Check if the current device have the bpf traffic stats accounting service
+     * running.
+     */
+    bool getBpfEnabled();
+
     /*
      * Swap the stats map config from current active stats map to the idle one.
      */
@@ -202,6 +208,8 @@ class TrafficController {
     netdutils::Status addRule(uint32_t uid, UidOwnerMatchType match, uint32_t iif = 0)
             REQUIRES(mMutex);
 
+    bool mBpfEnabled;
+
     // mMutex guards all accesses to mConfigurationMap, mUidOwnerMap, mUidPermissionMap,
     // mStatsMapA, mStatsMapB and mPrivilegedUser. It is designed to solve the following
     // problems:
-- 
2.37.1

