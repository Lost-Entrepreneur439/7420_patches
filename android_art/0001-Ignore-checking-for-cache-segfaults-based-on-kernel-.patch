From f9c5f0de8165b11ecbf7317011cf494bd5bb012e Mon Sep 17 00:00:00 2001
From: Fakeman <55951275+fakemanoan@users.noreply.github.com>
Date: Fri, 21 Jun 2024 09:37:59 +0100
Subject: [PATCH] Ignore checking for cache segfaults based on kernel ver

Our kernel already has the fix direct from Samsung, so this is an unnecessary check

Change-Id: Ifeee891c6272b8b00270cb0594cc8eb135d650d5
---
 libartbase/base/utils.cc | 20 +-------------------
 1 file changed, 1 insertion(+), 19 deletions(-)

diff --git a/libartbase/base/utils.cc b/libartbase/base/utils.cc
index 19311b3ded..928d484dcd 100644
--- a/libartbase/base/utils.cc
+++ b/libartbase/base/utils.cc
@@ -157,25 +157,7 @@ bool FlushCpuCaches(void* begin, void* end) {
 #endif
 
 bool CacheOperationsMaySegFault() {
-#if defined(__linux__) && defined(__aarch64__)
-  // Avoid issue on older ARM64 kernels where data cache operations could be classified as writes
-  // and cause segmentation faults. This was fixed in Linux 3.11rc2:
-  //
-  // https://github.com/torvalds/linux/commit/db6f41063cbdb58b14846e600e6bc3f4e4c2e888
-  //
-  // This behaviour means we should avoid the dual view JIT on the device. This is just
-  // an issue when running tests on devices that have an old kernel.
-  static constexpr int kRequiredMajor = 3;
-  static constexpr int kRequiredMinor = 12;
-  struct utsname uts;
-  int major, minor;
-  if (uname(&uts) != 0 ||
-      strcmp(uts.sysname, "Linux") != 0 ||
-      sscanf(uts.release, "%d.%d", &major, &minor) != 2 ||
-      (major < kRequiredMajor || (major == kRequiredMajor && minor < kRequiredMinor))) {
-    return true;
-  }
-#endif
+// Force allow as our kernel incorporates cache segfault fixes from Samsung. Improves performance
   return false;
 }
 
-- 
2.25.1

